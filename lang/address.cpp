#include "address.h"
#include "structural_node.h"
#include "program.h"

TLANG_NAMESPACE_BEGIN

// *****************************************************************************
// these structures are used for maintaining metadata and sparsity.
// Their look_up function takes a merged index, but they don't know where do the
// bits come from.

template <int n_, typename child_type>
struct fixed {
  static constexpr int n = n_;
  child_type children[n];
  TC_FORCE_INLINE child_type &look_up(int i) {  // i is flattened index
    return children[i];
  }
};

template <int n_, typename child_type>
struct dynamic {
  static constexpr int n = n_;
  std::vector<child_type> children;
  TC_FORCE_INLINE child_type &look_up(int i) {  // i is flattened index
    return children[i];
  }
};

template <typename... child_types>
struct forked {
  using child_type_tuple = std::tuple<child_types...>;
  child_type_tuple children;

  template <int i>
  TC_FORCE_INLINE auto &get() {
    return std::get<i>(children);
  }
};
// *****************************************************************************

// This part should be generated by the compiler
// The tree is built in a bottom-up order, so that upper level can learn about
// the size etc. of children.


/*
using placeholder_u = real;
using placeholder_v = real;
using node1 = forked<placeholder_u, placeholder_v>;
using root = fixed<32, node1>;

root r;

// Global look_up functions that take a data structure instance, and an index
// bit mixing is done here.
real &look_up_u(root &r, int i, int j, int k) {
  auto &n1 = r.look_up(i * 32 + j);
  auto &n2 = n1.get<1>();
  return n2;
}
*/

// All data structure originates from a "root", which is a forked node.

auto test_snode(){
  Program prog(Arch::x86_64);

  auto i = Expr::index(0);
  Expr u;
  u->data_type = DataType::i32;

  prog.layout([&] {
    root.fixed(i, 32).place(u);
  });

  for (int i = 0; i < 10; i++) {
    // u.access(i);
  }
}

TLANG_NAMESPACE_END
